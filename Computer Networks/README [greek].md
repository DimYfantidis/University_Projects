# Δίκτυα Επικοινωνιών
> Εργασία Εξαμήνου  
> Υφαντίδης Δημήτριος (ΑΕΜ: 3938)

<hr>

## **_Εισαγωγή_**

Η παρούσα εργασία υλοποιήθηκε στη γλώσσα **Java (v19.0.1)** με τη χρήση της τεχνολογίας των **Sockets** (Socket, ServerSocket, Thread, I/O Streams).  
Αρχικά, θα παρουσιαστεί το _Client side_ και έπειτα το _Server side_ της υλοποίησης.  
Παρατίθενται οι κλάσεις που χρησιμοποιήθηκαν καθώς και η οργανωτική τους δομή στο project

**MessagingApp** package:
* **Client** package:
    * _Client_ class 
* **Server** package:
    * _Message_ class
        * _Message.Builder_ class
    * _Account_ class
    * _Logger_ class
    * _Server_ class
        * _Server.ConnectionHandler_ class

**<span style="color:red">
Σημειώνεται ότι δεν χρησιμοποιείται η τεχνολογία RMI, αλλά ούτε και η χρήση του Serialization.  
Η επικοινωνία μεταξύ Διακομιστή και Πελάτη πραγματοποιείται εξ' ολοκλήρου με τη μετάδοση <u>_συμβολοσειρών_</u>  
μέσω <u>_ρευμάτων κειμένου_</u> και ΟΧΙ ρευμάτων αντικειμένων.
</span>**

<hr>

## **_Client Side_**
Το Client Side είναι υλοποιημένο μέσα στην κλάση Client που έχει τρία μέλη: 

```java
private final Socket clientSocket;  // Θεμελιώνεται η TCP επικοινωνία
private final PrintWriter out;      // Στέλνει μηνύματα του Client στον Server
private final BufferedReader in;    // Λαμβάνει μηνύματα που στέλνει ο Server
```

Ο Client κατασκευάζεται ως στιγμιότυπο της κλάσης και μέσω μεθόδων της Client πραγματοποιείται η επικονωνία.  
Από τη συνάρτηση **Client.main(String[] args)** καταλαβαίνουμε ότι η υλοποίηση χωρίζεται σε τρία μέρη:
> 1. Γίνεται κατάλληλο **parsing** στα αρχικά ορίσματα γραμμής εντολών.  
> 2. Με αυτά κατασκευάζεται το Client object και, με τη χρήση της **transmit(...)** μεταδίδουμε:
>    * το FN_ID
>    * τα αναμενόμενα ορίσματα που ακολουθούν μετά από το εκάστοτε FN_ID
> 3. Αναμένονται τα αποτελέσματα προς εκτύπωση με τη χρήση της **receiveAll()**, όπως αυτά θα υπολογιστούν από τον διακομιστή και, έπειτα, ο πελάτης θα τερματίσει.

**<span style="color:red">
Η πλευρά υλοποίησης του Client δεν έχει απολύτως καμία πληροφορία για την ύπαρξη οποιασδήποτε άλλης κλάσης
</span>** (όπως Message, Account κλπ).  
Απλά περιμένει να του σταλθούν σειρές κειμένου για να τις εκτυπώσει. Λειτουργεί, δηλαδή, σαν τερματικό.

<hr>

## **_Server Side_**

<br>

> **Κλάση Message:**  
περιέχει τα απαιτούμενα πεδία όπως ζητούνται, με ένα επιπλέον, τη λογική τιμή **isDeleted**.
```java
private boolean isRead;         // Αν έχει διαβαστεί από τον παραλήπτη
private boolean isDeleted;      // Τα μηνύματα δεν διαγράφονται από το inbox, απλά μαρκάρονται ως διεγραμμένα
private final int messageId;    // Ανατίθεται στη θέση του στο inbox του εκάστοτε χρήστη
private final String sender;    // Ο αποστολέας
private final String receiver;  // Ο παραλήπτης
private final String body;      // Το κείμενο του μηνύματος
```
Η εμφωλευμένη κλάση **Builder** υπάρχει λόγω του προτύπου σχεδίασης που ακολουθήθηκε για την κατασκευή των μηνυμάτων.  

<br> <br>

> **Κλάση Account:**  
Αναπαριστά τους χρήστες. Τα απαιτούμενα πεδία είναι:  
```java
private final String username;          // Όνομα Χρήστη
private final int authToken;            // Κωδικός Χρήστη
private final List<Message> messageBox; // Λίστα μηνυμάτων
```

Περιέχει και διάφορες στατικές μεθόδους και ιδιότητες για σκοπούς αλληλεπίδρασης με τη βάση δεδομένων, π.χ:
```java
private static final HashMap<Integer, Account> databaseByToken;    // Γρήγορη εύρεση χρήστη με βάση τον κωδικό
private static final HashMap<String, Account> databaseByUsername;  // Γρήγορη εύρεση χρήστη με βάση το όνομα
```

Απαγορεύεται η απευθείας χρήση του κατασκευαστή. Αντί αυτού, χρησιμοποιούνται ο μέθοδοι **extract(...)** και **store(String)**.  

<br> <br>

> **Κλάση Logger:**  
Απλά εκτυπώνει τα διάφορα γεγονότα στο τερματικό του διακομιστή όπως
* Εκκίνηση και Τερματισμός
* Σύνδεση πελάτη (_ζητούμενη λειτουργία, παραμέτρους κλπ_)
* Ημερομηνία και ώρα γεγονότος  

<br> <br>

> **Κλάση ConnectionHandler** (Εμφωλευμένη στην Server):  
Κάθε στιγμιότυπο εξυπηρετεί ένα νέο πελάτη.  

Κληρονομεί από την κλάση **Thread** για να μπορεί ο server να εξυπηρετεί  πολλούς clients ταυτόχρονα. Οι ιδιότητές του είναι:
```java
private final Socket clientSocket;  // Η TCP πρίζα του πελάτη
private final BufferedReader in;    // Διαβάζει μηνύματα από τον πελάτη
private final PrintWriter out;      // Στέλνει μηνύματα στον πελάτη
```
Με τη χρήση της επαναπροσδιορισμένης μεθόδου **run()**, ο server διαβάζει το FN_ID και, με τη χρήση μιας *switch* statement,  
επιλέγεται η κλήση της κατάλληλης μεθόδου. Κάθε μέθοδος πραγματοποιεί την αντίστοιχη λειτουργία που ζητάται από την εκφώνηση.  
Άρα, η ConnectionHandler διαθέτει και άλλες **6 βασικές συναρτήσεις** για αυτόν ακριβώς τον σκοπό.  
```java
public void createAccount() throws IOException
public void printAccounts() throws IOException
public void sendMessage() throws IOException
public void showInbox() throws IOException
public void readMessage() throws IOException
public void deleteMessage() throws IOException
```
Κάθε μία από αυτές τις συναρτήσεις χρησιμοποιεί το ρεύμα εισόδου τόσες φορές όσες αναμένονται να είναι τα ορίσματα.  
Στο τέλος μεταδίδει τα αποτελέσματα στον πελάτη. 

*Δεν υπάρχει ρητός έλεγχος για ανεπαρκή αριθμό ορισμάτων, αλλά σε αυτή την περίπτωση θα προκύψει σφάλμα έτσι κι αλλιώς  
που δε θα επηρεάσει αρνητικά τον διακομιστή, ούτε τη βάση δεδομένων του*.

<br> <br>

> **Κλάση Server:**  
Αποτελεί την υλοποίηση του Server Side, μαζί με την εμφωλευμένη κλάση **ConnectionHandler**.

Επεκτείνει την κλάση **Thread** για να μπορεί να τερματίσει φυσιολογικά, χωρίς τη χρήση exception.  
Δηλαδή, αναμένεται ασύγχρονα το πάτημα του κουμπιού _Enter_ για τον τερματισμό του server. Περιέχει τα εξής πεδία:
```java
private final ServerSocket serverSocket; // Η TCP πρίζα
private volatile boolean done; // Τερματική συνθήκη της overridden μεθόδου run()
private final ArrayList<ConnectionHandler> connections; // Η λίστα των ταυτόχρονων πελατών που εξυπηρετόυνται
```
Ουσιαστικά, η αλληλεπίδραση με έναν πελάτη είναι υλοποιημένη στον ConnectionHandler.  
Η πρακτική λειτουργία της κλάσης Server είναι λιγότερο πολύπλοκη και βρίκεται στην επαναπροσδιορισμένη μέθοδο **run()**:
1. Περιμένει για την άφιξη ενός πελάτη
2. Του αναθέτει έναν ConnectionHandler για να διεκπεραιώσει **ασύγχρονα** το ερώτημά του
3. Επαναλαμβάνει τη διαδικασία μέχρι να ικανοποιηθεί η τερματική συνθήκη που αναφέρθηκε πιο πάνω
